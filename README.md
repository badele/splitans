```text
⠀⣠⣴⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣦⣄⠀
⣰⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣆
⣿⣿⣿⡿⠿⠿⠿⠿⠿⢿⣿⡿⠿⠿⠿⠿⠿⠿⣿⣿⣿⠿⠿⠿⣿⣿⣿⣿⣿⣿⡿⠿⠿⠿⠿⠿⠿⢿⡿⠿⠿⠿⠿⠿⠿⠿⢿⣿⣿⡿⠿⠿⠿⠿⣿⣿⣿⣿⠿⠿⢿⣿⣿⡿⠿⠿⣿⣿⣿⡿⠿⠿⠿⠿⠿⣿⣿⣿
⣿⣿⡏⠀⠀⠀⠀⠀⠀⢸⣿⡇⠀⠀⠀⠀⠀⠀⠀⢻⣿⠀⠀⠀⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⢸⡇⠀⠀⠀⠀⠀⠀⠀⠀⣿⡿⠀⠀⠀⠀⠀⠸⣿⣿⡏⠀⠀⠀⠻⣿⠁⠀⠀⢹⣿⠃⠀⠀⠀⠀⠀⠀⢹⣿⣿
⣿⣿⠁⠀⠀⠰⠶⢶⣶⣾⣿⡇⠀⠀⢰⣶⡆⠀⠀⢸⣿⠀⠀⠀⣿⣿⣿⣿⣿⣿⣷⣶⡆⠀⠀⢰⣶⣿⣷⣶⣶⠀⠀⠀⢶⣶⣾⣿⠃⠀⠀⣶⡄⠀⠀⢻⣿⡏⠀⠀⠀⠀⠘⠃⠀⠀⢹⣿⠀⠀⠀⠶⠶⢶⣶⣿⣿⣿
⣿⣿⣇⠀⠀⠀⠀⠀⠀⠙⣿⡇⠀⠀⠘⠛⠃⠀⠀⢸⣿⠀⠀⠀⣿⣿⠋⠉⠙⣿⣿⣿⡇⠀⠀⢸⣿⣿⣿⣿⣿⠀⠀⠀⢹⣿⣿⡏⠀⠀⠰⠛⠓⠀⠀⠈⣿⡏⠀⠀⠀⡀⠀⠀⠀⠀⢹⣿⡄⠀⠀⠀⠀⠀⠈⢹⣿⣿
⣿⣿⣿⣿⣶⣶⣤⠀⠀⠀⣿⡇⠀⠀⢀⣀⣀⣀⣤⣿⣿⠀⠀⠀⣿⣿⠀⠀⠀⣿⣿⣿⡇⠀⠀⢸⣿⣿⣿⣿⣿⠀⠀⠀⢹⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⣿⡏⠀⠀⠀⣿⣄⠀⠀⠀⢹⣿⣿⣷⣶⣶⡄⠀⠀⠈⣿⣿
⣿⣿⠁⠀⠀⠀⠀⠀⠀⢠⣿⡇⠀⠀⢸⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⣿⡇⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⠀⠀⠀⢹⣿⣿⡇⠀⠀⢸⣿⣿⠀⠀⠀⣿⡏⠀⠀⠀⣿⣿⠂⠀⠀⢹⣿⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿
⣿⣿⣧⣤⣤⣤⣤⣤⣶⣿⣿⣷⣤⣤⣼⣿⣿⣿⣿⣿⣿⣦⣤⣤⣤⣤⣤⣤⣤⣿⣧⣤⣤⣤⣤⣤⣤⣾⣿⣿⣿⣦⣤⣤⣿⣿⣿⣧⣤⣤⣾⣿⣿⣤⣤⣤⣿⣿⣤⣤⣴⣿⣿⣧⣤⣤⣿⣿⣦⣤⣤⣤⣤⣴⣶⣿⣿⣿
⢹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡏
⠀⠙⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠋⠀
```

Splitans is a tokenization tool that parses ANSI files and separates text from
ANSI sequences. The text is saved to a file with the `.neot` extension and the
control sequences to a file with the `.neos` extension.

It is also possible to export to various formats, such as table or JSON.

## Usage

By default, `splitans` displays the plain text content (without ANSI codes) to
stdout.

```bash
# Parse a file and display plain text (default behavior)
./splitans file.ans

# Save plain text to a file using output redirection
./splitans file.ans > output.txt

# Copy to termbin.com
./splitans file.ans | nc termbin.com 9999

# Read from pipe
cat file.ans | ./splitans
echo -e "\x1b[31mRed Text\x1b[0m" | ./splitans

# Display tokens in table format
./splitans -t file.ans
cat file.ans | ./splitans -t

# Export to JSON
./splitans -j file.ans

# Display statistics
./splitans -s file.ans

# Export to multiple files (.neot and .neos)
./splitans -m output_filename file.ans
```

## MISC

### Test

#### Parsed Correctly

```bash
success=0; total=0;
for file in $(find . -name "*.ANS"); do
    total=$((total+1));
    if ./splitans -e cp437 -f ansi -E utf8 -F ansi "$file" > /dev/null 2>&1; then
        success=$((success+1));
    else
        echo "FAILED: $file";
    fi;
done;

echo "Success: $success/$total"
```

#### Check output content

```bash
echo "" > /tmp/result.txt
for file in $(find . -name "*.ANS"); do
    echo -e "Parsing $file"

    printf "=%.0s" {1..80} >> /tmp/result.txt
    echo -e "\n== ${file}\n" >> /tmp/result.txt
    ./splitans -e cp437 -f ansi -E utf8 -F ansi "$file" >> /tmp/result.txt 2>/dev/null
    echo -e >> /tmp/result.txt
done
```

## Sources

- Resources
  - https://16colo.rs
  - https://wezterm.org/escape-sequences.html#graphic-rendition-sgr
  - https://vt100.net/docs/vt510-rm/chapter4.html
  - https://invisible-island.net/xterm/ctlseqs/ctlseqs.html
  - https://ecma-international.org/wp-content/uploads/ECMA-48_5th_edition_june_1991.pdf
- Logo Font
  - https://djr.com/bungee
